# 7.08 王爽汇编语言（五）

## 检测点 3.1
内存中字的存储：由于内存单元是字节单元，所以一个字需要两个地址连续的内存单元来存放；其中这个字的低位字节需要保存在低地址单元，高位字节需要保存在
高地址单元；

mov 指令可用于将：
（1）数据直接送入寄存器:
mov ax, 1000h
（2）将一个寄存器的内容送入另一个寄存器:
mov ax, bx
（3）将内存单元的内容送入指定寄存器:
需要先将数据在内存中的段地址送入 ds 段寄存器，但是不能直接将数据送往 ds 寄存器，需要其他寄存器中转（CPU 设计的原因）
所以首先 mov ax, 1000h 然后 mov ds, ax 最后获取内存单元 1000:0 中的数据的话，则使用 mov ax, [0] 其中 [] 中的 0 是数据的偏移地址；
（4）将寄存器中的内容送入内存：
知道（3）就能推出（4）；对于 mov 指令来说就是 mov [内存单元偏移地址], 寄存器名称；

add、sub 指令不能对段寄存器进行操作

巩固一下 jmp 指令干嘛的：
jmp 某一个合法寄存器：即用寄存器的值修改 IP 寄存器；详情见 P33；
jmp "段地址:偏移地址" 则同时修改 cs 和 ip 寄存器的值；

## 作业答案
（1）：
没啥难度，不过要注意的是开头；
首先计算一下物理地址，ds 寄存器存放 0001h，那么 mov ax, [0000] 的话，物理地址算一下：即 00010h，就这里注意一下，后续没啥难度，就是算；
答案如下：
AX = 2662H
BX = E626H
AX = E626H
AX = 2662H
BX = D6E6H
AX = FD48H
AX = 2C14H
AX = 0000H
AX = 00E6H
BX = 0000H
BX = 0026H
AX = 000CH

（2）：
```shell
CS = 2000H IP = 0 DS = 1000H AX = 0 BX = 0;
#（1）写出 CPU 执行的指令序列：
- 首先计算一下下一条执行的指令的物理地址：20000H，所以第一条执行的指令是 mov ax, 6622H，后续就简单了；
答案如下：
mov ax, 6622H
jmp 0ff0:0100 # 此时 cs = 0ff0h ip = 0100h 0ff00h + 0100h = 10000h
mov ax, 2000h
mov ds, ax # ds = 2000h
mov ax, [0008] # 此时内存数据的物理地址为 20008h, ax = c389h
mov ax, [0002] # 此时内存数据的物理地址为 20002h, ax = ea66h
```

## 总结
慢慢来！加油！其实知识并不难，觉得难的人只是缺乏耐心把他弄懂罢了。