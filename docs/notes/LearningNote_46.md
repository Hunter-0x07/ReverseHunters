# 7.40 王爽汇编语言（三十七）

## 中间笔记
本章继续讲标志寄存器；
8086 CPU 的 flag 寄存器的结构如下：
15   14   13   12   11   10   9   8   7   6   5   4   3   2   1   0
                    of   df   if  tf  sf  zf      af      pf      cf

```shell
1.CF（carry flag）标志位：进位标志位，在进行无符号运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
2.OF（overflow flag）标志位：溢出标志位，在进行有符号运算的时候，如果运算结果发生了溢出，那么OF置为1，否则置为0；

# 举个例子
mov al, 98
add al, 99
对于无符号运算来说，98 + 99 = 197，其没有超过 8 位无符号表示（0 ~ 255），但是超过了 8 位有符号表示（-127 ~ 128），所以此时 CF 置为1，
```

## 检测点 11.2
```shell
# sub al, al
解析：结果为 0，所以 ZF 置为 1；1的个数为偶数，所以 PF 置为 1；最高位为 0，如果看作有符号数，则为正数，所以 SF 置为 0；没有产生进位和溢出，所以 CF 和 OF 都为 0；

# mov al, 10h
解析：目前已知传送指令mov、push、pop 不影响标志位，标志位维持上一步状态；

# add al, 90h
解析：al = 10 + 90h = A0h，zf 置为 0；A0h 换算成二进制 1010 0000；1的个数为偶数，所以 PF 置 1；最高位是 1，所以 SF 置 1；A0h，有符号运算来说是 -81；所以 CF 和 OF 都为 0；

# mov al, 80h
解析：目前已知传送指令mov、push、pop 不影响标志位，标志位维持上一步状态；

# add al, 80h
解析：al = 80h + 80h = 100h，al 此时保存了00，所以 ZF 置为 1（经过olldbg测试，看来 zf 标志位判断的是最后寄存器的结果，是不管进位结果的）；
al 的 00h 换算成二进制 0000 0000（经过olldbg测试，PF 标志位判断的也是最后寄存器的结果，是不管进位结果的），所以 PF 判断 1 的个数为 0（即偶数），所以 PF 置 1；
al 的 00h，最高位为 0，所以 SF 置 0；针对无符号运算来说，al 只能保存 0 ~ 255，而结果是 256，所以其产生了进位，CF 置为 1；
针对有符号运算来说，80h 换算成二进制 1000 0000，为负数 -128，两者相加即 -128 -128，溢出，所以 OF 置为 1；

# mov al, 0fch
解析：目前已知传送指令mov、push、pop 不影响标志位，标志位维持上一步状态；

# add al, 05h
解析：al = fch + 05h = 101h，所以 zf 置 0；al保存了 01h 换算成二进制，即 0000 0001，所以 pf 置 0；SF 置 0；101h，对于无符号运算来说，已经进位了；
但是对于有符号运算来说，fch 为 1111 1100，即为负数 -4，而 05h 是 5，则相加为 1，在范围 -128 ~ 127 内，没有溢出;

# mov al, 7dh
解析：目前已知传送指令mov、push、pop 不影响标志位，标志位维持上一步状态；

# add al, 0bh
解析：al = 7dh + 0bh = h，所以 zf 置 0；8dh 换算成二进制 1000 1000，所以 pf 置 1；SF 置 1；
对于无符号运算来说，没有进位，CF 置为 1；而对于有符号运算来讲，7dh 换算成二进制 0111 1101，为正数 125；0bh 为 0000 1011，为正数11，相加为 136，超过 127，则溢出，所以 OF = 1；

# 参考答案链接：
https://blog.csdn.net/shaco_/article/details/105500175
```

## 总结
明天继续补充
2022.6.6 11：48
主要是 OF 溢出运算时，需要注意，先看执行的时候操作数是否为负数，如果为负数，需要先换算为十进制负数后再进行计算；